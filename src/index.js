module.exports = function check(str, bracketsConfig) {
  let config = {};
  let arr = [];
  
  for (let item of bracketsConfig) {
   config[item[0]] = item[1];
  }

  for (let char of str) {
    if (Object.keys(config).includes(char) &&  config[char] !== char) {
      arr.push(char);
      
    } 
    else if ((Object.values(config).includes(char) || Object.keys(config).includes(char))&& char === config[arr[arr.length - 1]]) {
console.log(char);
      arr.pop();
      
    } else if (Object.values(config).includes(char)){
    arr.push(char);
   
  }

 
}
return arr.length === 0 ? true : false;
}








//я делал через массив. если открывается скобка - добавляю в массив, если закрывается - проверяю, соответствует ли последней открытой. если да - удаляю из массива последнюю запись, если нет - возвращаю false
//Если из правильной строки удалить пару рядом стоящих скобок, то строка останется правильной. Это намек.
// проверить, что каждой открывающейся скобке соответствует закрывающаяся
// @Федор Одинцов (@Fodin) это, получается, в строке, которая чисто набор скобочек. А массив тогда зачем?..
// Федор Одинцов (@Fodin)Today at 11:49 AM
// @Angulema(@angoulema) чтобы знать, какая открывающая "скобка" соответствует какой закрывающей.
//тебе на вход передается строка со скобками и массив в котором указаны те скобки которые тебе надо чекать
// чекаешь правильность расстановки скобок в строке
//и это делать не за один проход, а в бесконечном цилке или в рекурсии, логика примерно такая, сохраняешь в переменную длину строки, производишь удаление пары скобок, замеряешь опять длину строки и если она уменьшилась, значит цикл надо повторить, если длина строки до удалени и после осталась одинакова значит удаление прекращаешь и выходишь из цикла, потом смотришь в строку, если она пустая, значит все скобки были парные и условие выполнилось, если там что-то есть тогда условие не выполнилось

// /2020
// @Valentyn (@nexgenua) я искал помойму скобки через регулярное выражение и не с внешних а наоборот самых вложенных т.е. ищешь скобки в которых нет скобок, надеюсь доходчиво

// Но работает это не всегда. Хороший алгоритм есть - в одном цикле перебрать массив. Если ( тогда +1 если ) то -1 если в минус уходит - сразу break. А потом надеемся что 0 получим
// Если просто сравнить то попадется на ())(()
// там приходит 2 параметра в функцию, строка со скобками и массив с парами скобок (точнее то, что нужно считать скобками), нужно проверить строку, что бы после каждой открывающейся скобки шла закрывающаяся, не просто количество открывающих и закрывающих скобок
// можно просто сравнить i и i+1 элемент с тем что дается и удалять их от туда, i обнулять каждый раз чтобы с сначала строки идти, без всяких стеков
// Valentyn (@nexgenua)03/08/2020
// @Wadim(@Wadimx199789)  я делал через рекурсию, задачка очень простая, можешь у меня подсмотреть и реализовать по своему